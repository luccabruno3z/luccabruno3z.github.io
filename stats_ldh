import requests
from bs4 import BeautifulSoup
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import plotly.express as px
import os

os.environ["OMP_NUM_THREADS"] = "1"

# URL del clan
url = "https://prstats.realitymod.com/clan/11204/ldh"
response = requests.get(url)
soup = BeautifulSoup(response.text, 'html.parser')

# Extraer la tabla de datos
tabla = soup.find('table')
filas = tabla.find_all('tr')[1:]  # Omitir encabezado

def convertir_valor(valor):
    try:
        if 'M' in valor:
            return int(float(valor.replace('M', '')) * 1_000_000)
        elif 'k' in valor:
            return int(float(valor.replace('k', '')) * 1_000)
        else:
            return int(valor.replace(',', '').strip())
    except ValueError:
        return None

datos_clan = []

for fila in filas:
    columnas = fila.find_all('td')
    try:
        player = columnas[1].text.strip()
        total_score = convertir_valor(columnas[2].text.strip())
        total_kills = convertir_valor(columnas[3].text.strip())
        total_deaths = convertir_valor(columnas[4].text.strip())
        rounds = convertir_valor(columnas[5].text.strip())

        if rounds and rounds > 0:
            datos_clan.append({
                "Player": player, 
                "Total Score": total_score, 
                "Total Kills": total_kills, 
                "Total Deaths": total_deaths, 
                "Rounds": rounds
            })
    except IndexError:
        print(f"Error al procesar datos de {fila}")

df = pd.DataFrame(datos_clan).dropna()

# Calcular métricas adicionales
df["K/D Ratio"] = df.apply(lambda row: row["Total Kills"] / row["Total Deaths"] if row["Total Deaths"] > 0 else 0, axis=1)
df["Score per Round"] = df.apply(lambda row: row["Total Score"] / row["Rounds"] if row["Rounds"] > 0 else 0, axis=1)
df["Kills per Round"] = df.apply(lambda row: row["Total Kills"] / row["Rounds"] if row["Rounds"] > 0 else 0, axis=1)

# Normalizar los datos
scaler = StandardScaler()
data_scaled = scaler.fit_transform(df[['K/D Ratio', 'Score per Round']])

# Aplicar K-means con 20 clusters
kmeans = KMeans(n_clusters=20, random_state=42)
df["Cluster"] = kmeans.fit_predict(data_scaled)

# Reordenar clusters para que 0 sea el mejor y 19 el peor
cluster_order = df.groupby('Cluster')[['K/D Ratio', 'Score per Round']].mean().sort_values(
    by=['K/D Ratio', 'Score per Round'], ascending=[False, False]
).index.tolist()

cluster_reorder_map = {cluster: i for i, cluster in enumerate(cluster_order)}
df['Cluster'] = df['Cluster'].map(cluster_reorder_map)

# Etiquetas de los clusters
labels = {
    0: "Rendimiento legendario",
    1: "Rendimiento excepcional",
    2: "Rendimiento sobresaliente",
    3: "Rendimiento élite",
    4: "Rendimiento excelente",
    5: "Rendimiento notable",
    6: "Rendimiento destacado",
    7: "Rendimiento alto",
    8: "Rendimiento muy bueno",
    9: "Rendimiento bueno",
    10: "Rendimiento promedio alto",
    11: "Rendimiento promedio",
    12: "Rendimiento promedio bajo",
    13: "Rendimiento aceptable",
    14: "Rendimiento bajo",
    15: "Rendimiento insuficiente",
    16: "Rendimiento deficiente",
    17: "Rendimiento muy deficiente",
    18: "Rendimiento crítico",
    19: "Rendimiento extremadamente bajo"
}

df['Cluster Label'] = df['Cluster'].map(labels)

# Visualización interactiva
fig = px.scatter(df, x="K/D Ratio", y="Score per Round", hover_name="Player", color="Cluster Label")
fig.show()

# Guardar los datos en un archivo JSON
with open("players_clusters.json", "w") as json_file:
    df.to_json(json_file, orient="records", lines=True)

# Guardar gráfico como archivo HTML
fig.write_html("grafico_interactivo.html")

# Mostrar resultados ordenados
print(df.sort_values(by=["Cluster", "K/D Ratio"], ascending=[True, False])[["Player", "K/D Ratio", "Score per Round", "Kills per Round", "Cluster Label"]])
